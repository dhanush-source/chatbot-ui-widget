class ChatToggle {
  constructor(config) {
    this.config = config;
  }
  render() {
    if (this.config.layout !== "bubble" || !this.config.showToggle) {
      return "";
    }
    return `
      <div class="chatbot-toggle" id="chatbot-toggle">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
          <path d="M21 11.5C21.0034 12.8199 20.6951 14.1219 20.1 15.3C19.3944 16.7118 18.3098 17.8992 16.9674 18.7293C15.6251 19.5594 14.0782 19.9994 12.5 20C11.1801 20.0035 9.87812 19.6951 8.7 19.1L3 21L4.9 15.3C4.30493 14.1219 3.99656 12.8199 4 11.5C4.00061 9.92179 4.44061 8.37488 5.27072 7.03258C6.10083 5.69028 7.28825 4.6056 8.7 3.90003C9.87812 3.30496 11.1801 2.99659 12.5 3.00003H13C15.0843 3.11502 17.053 3.99479 18.5291 5.47089C20.0052 6.94699 20.885 8.91568 21 11V11.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </div>
    `;
  }
}
class Header {
  constructor(config) {
    this.config = config;
  }
  render() {
    const minimizeButton = this.config.layout !== "inline" && this.config.layout !== "modal" ? `
      <button class="chatbot-btn-minimize" id="chatbot-minimize">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
          <path d="M5 12H19" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </button>
    ` : "";
    return `
      <div class="chatbot-header">
        <div class="chatbot-header-info">
          <div class="chatbot-avatar">
            <img src="${this.config.avatar.bot}" alt="Bot" />
          </div>
          <div class="chatbot-header-text">
            <div class="chatbot-name">Assistant</div>
            <div class="chatbot-status">Online</div>
          </div>
        </div>
        <div class="chatbot-header-actions">
          ${minimizeButton}
        </div>
      </div>
    `;
  }
}
class MessageList {
  render() {
    return `
      <div class="chatbot-messages" id="chatbot-messages">
      </div>
    `;
  }
}
class InputBox {
  constructor(config) {
    this.config = config;
  }
  render() {
    return `
      <div class="chatbot-input-container">
        <div class="chatbot-input-wrapper">
          <input 
            type="text" 
            class="chatbot-input" 
            id="chatbot-input" 
            placeholder="${this.config.placeholder}"
          />
          <button class="chatbot-btn-send" id="chatbot-send">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
              <path d="M22 2L11 13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M22 2L15 22L11 13L2 9L22 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
        </div>
      </div>
    `;
  }
}
class ChatWindow {
  constructor(config) {
    this.config = config;
    this.header = new Header(config);
    this.messageList = new MessageList();
    this.inputBox = new InputBox(config);
  }
  render() {
    return `
      <div class="chatbot-window" id="chatbot-window">
        ${this.header.render()}
        ${this.messageList.render()}
        ${this.inputBox.render()}
      </div>
    `;
  }
}
class Message {
  constructor(config) {
    this.config = config;
  }
  render({ text, html, isHtml, sender, timestamp }) {
    const timeStr = timestamp.toLocaleTimeString([], {
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    });
    const content = html || text;
    const isHtmlContent = isHtml || false;
    return `
      <div class="chatbot-message ${sender}">
        <div class="chatbot-message-avatar">
          <img src="${this.config.avatar[sender]}" alt="${sender}" />
        </div>
        <div class="chatbot-message-content">
          <div class="chatbot-message-bubble ${isHtmlContent ? "html-content" : ""}">${content}</div>
          <div class="chatbot-message-time">${timeStr}</div>
        </div>
      </div>
    `;
  }
}
class LoadingIndicator {
  constructor(config) {
    this.config = config;
  }
  render() {
    return `
      <div class="chatbot-message bot loading-indicator" id="chatbot-loading">
        <div class="chatbot-message-avatar">
          <img src="${this.config.avatar.bot}" alt="bot" />
        </div>
        <div class="chatbot-message-content">
          <div class="chatbot-message-bubble">
            <div class="chatbot-typing-indicator">
              <span></span>
              <span></span>
              <span></span>
            </div>
          </div>
        </div>
      </div>
    `;
  }
}
const getBaseStyles = (config) => {
  const theme = config.processedTheme || {};
  const cssVarDeclarations = Object.entries(theme).map(([key, value]) => `${key}: ${value};`).join("\n    ");
  const fallbackVars = `
    --primary-color: ${config.primaryColor || "#3B82F6"};
    --bg-primary: #1F2937;
    --bg-secondary: #374151;
    --bg-tertiary: #4B5563;
    --text-primary: #F9FAFB;
    --text-secondary: #D1D5DB;
    --text-muted: #9CA3AF;
    --border-color: #4B5563;
    --shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
    --radius: 12px;
    --radius-sm: 8px;
  `;
  return `
  :host {
    ${cssVarDeclarations || fallbackVars}
    --font-family: ${theme["--font-family"] || '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'};
    --font-size: ${theme["--font-size"] || "14px"};
  }

  .chatbot-widget {
    font-family: var(--font-family);
    font-size: var(--font-size);
    line-height: 1.5;
  }

  .chatbot-window {
    background: var(--bg-primary);
    border-radius: var(--radius, 12px);
    box-shadow: var(--shadow);
    display: none;
    flex-direction: column;
    overflow: hidden;
    border: 1px solid var(--border-color);
  }

  .chatbot-window.open {
    display: flex;
    animation: slideUp 0.3s ease;
  }

  @keyframes slideUp {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
`;
};
const getLayoutStyles = (config) => `
  /* Bubble Layout - Floating widget */
  .chatbot-layout-bubble {
    position: fixed;
    ${config.position.includes("bottom") ? "bottom: 20px;" : "top: 20px;"}
    ${config.position.includes("right") ? "right: 20px;" : "left: 20px;"}
    z-index: 1000;
  }

  .chatbot-layout-bubble .chatbot-window {
    position: absolute;
    bottom: 70px;
    right: 0;
    width: 380px;
    height: 500px;
  }

  .chatbot-toggle {
    width: 56px;
    height: 56px;
    background: var(--primary-color);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    cursor: pointer;
    box-shadow: var(--shadow);
    transition: all 0.3s ease;
    margin-left: auto;
  }

  .chatbot-toggle:hover {
    transform: scale(1.05);
    box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4);
  }

  /* Inline Layout - Part of page flow */
  .chatbot-layout-inline {
    position: relative;
    width: ${config.width};
    height: ${config.height};
    display: block;
  }

  .chatbot-layout-inline .chatbot-window {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex !important;
  }

  /* Embedded Layout */
  .chatbot-layout-embedded {
    position: relative;
    width: ${config.width};
    height: ${config.height};
  }

  .chatbot-layout-embedded .chatbot-window {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
  }

  /* Fullscreen Layout */
  .chatbot-layout-fullscreen {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 1000;
    width: 100vw;
    height: 100vh;
  }

  .chatbot-layout-fullscreen .chatbot-window {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    border-radius: 0;
    border: none;
  }

  /* Mobile responsiveness */
  @media (max-width: 480px) {
    .chatbot-layout-bubble {
      bottom: 10px;
      right: 10px;
      left: 10px;
    }

    .chatbot-layout-bubble .chatbot-window {
      width: 100%;
      height: 80vh;
      bottom: 70px;
      right: 0;
      left: 0;
      border-radius: var(--radius) var(--radius) 0 0;
    }
  }

  /* Modal Layout - Centered popup */
  .chatbot-layout-modal {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    right: 0 !important;
    bottom: 0 !important;
    z-index: 9999 !important;
    width: 100vw !important;
    height: 100vh !important;
    display: none; /* Hidden by default */
    align-items: center;
    justify-content: center;
    margin: 0 !important;
    padding: 0 !important;
  }

  .chatbot-layout-modal.open {
    display: flex; /* Show when open */
  }

  .chatbot-modal-backdrop {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(4px);
  }

  .chatbot-layout-modal .chatbot-window {
    position: relative;
    width: ${config.width || "800px"} !important;
    height: ${config.height || "600px"} !important;
    min-width: ${config.width || "800px"};
    min-height: ${config.height || "600px"};
    max-width: 95vw;
    max-height: 95vh;
    background: var(--bg-primary);
    border-radius: var(--radius);
    box-shadow: 0 25px 50px rgba(0, 0, 0, 0.25);
    border: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    animation: modal-slide-in 0.3s ease-out;
  }

  .chatbot-modal-close {
    position: absolute;
    top: 16px;
    right: 16px;
    background: rgba(255, 255, 255, 0.1);
    border: none;
    color: var(--text-primary);
    cursor: pointer;
    padding: 8px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    width: 32px;
    height: 32px;
    z-index: 10;
  }

  .chatbot-modal-close:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: scale(1.1);
  }

  @keyframes modal-slide-in {
    from {
      opacity: 0;
      transform: translateY(-20px) scale(0.95);
    }
    to {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
  }

  /* Mobile responsiveness for modal */
  @media (max-width: 768px) {
    .chatbot-layout-modal .chatbot-window {
      width: 95vw !important;
      height: 90vh !important;
      min-width: 95vw;
      min-height: 90vh;
      max-width: 95vw;
      max-height: 90vh;
    }
  }
`;
const headerStyles = `
  .chatbot-header {
    background: var(--header-bg, var(--bg-secondary));
    padding: var(--header-padding, 16px);
    display: flex;
    align-items: center;
    justify-content: space-between;
    border-bottom: 1px solid var(--header-border, var(--border-color));
  }

  .chatbot-header-info {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .chatbot-avatar {
    width: var(--header-avatar-size, 40px);
    height: var(--header-avatar-size, 40px);
    border-radius: 50%;
    overflow: hidden;
    background: var(--primary-color);
  }

  .chatbot-avatar img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .chatbot-name {
    font-weight: 600;
    color: var(--header-text, var(--text-primary));
    margin-bottom: 2px;
  }

  .chatbot-status {
    font-size: 12px;
    color: var(--header-status, var(--text-muted));
  }

  .chatbot-header-actions {
    display: flex;
    gap: 8px;
  }

  .chatbot-btn-minimize {
    background: none;
    border: none;
    color: var(--text-secondary);
    cursor: pointer;
    padding: 8px;
    border-radius: var(--radius-sm, 8px);
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
  }

  .chatbot-btn-minimize:hover {
    background: var(--bg-tertiary);
    color: var(--text-primary);
  }
`;
const messagesStyles = `
  .chatbot-messages {
    flex: 1;
    padding: var(--message-spacing, 16px);
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: var(--message-spacing, 16px);
  }

  .chatbot-messages::-webkit-scrollbar {
    width: 4px;
  }

  .chatbot-messages::-webkit-scrollbar-track {
    background: var(--bg-secondary);
  }

  .chatbot-messages::-webkit-scrollbar-thumb {
    background: var(--border-color);
    border-radius: 2px;
  }

  .chatbot-message {
    display: flex;
    gap: 8px;
    max-width: var(--message-max-width, 80%);
  }

  .chatbot-message.user {
    align-self: flex-end;
    flex-direction: row-reverse;
  }

  .chatbot-message-avatar {
    width: var(--message-avatar-size, 32px);
    height: var(--message-avatar-size, 32px);
    border-radius: 50%;
    overflow: hidden;
    flex-shrink: 0;
  }

  .chatbot-message-avatar img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .chatbot-message-content {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .chatbot-message-bubble {
    padding: 12px 16px;
    border-radius: var(--message-radius, var(--radius-sm, 8px));
    font-size: 14px;
    line-height: 1.4;
    word-wrap: break-word;
  }

  .chatbot-message.bot .chatbot-message-bubble {
    background: var(--bot-bubble-bg, var(--bg-secondary));
    color: var(--bot-bubble-text, var(--text-primary));
    border-bottom-left-radius: 4px;
  }

  .chatbot-message.user .chatbot-message-bubble {
    background: var(--user-bubble-bg, var(--primary-color));
    color: var(--user-bubble-text, white);
    border-bottom-right-radius: 4px;
  }

  .chatbot-message-time {
    font-size: 11px;
    color: var(--message-timestamp, var(--text-muted));
    margin-top: 4px;
  }

  .chatbot-message.user .chatbot-message-time {
    text-align: right;
  }

  /* HTML/Markdown content formatting */
  .chatbot-message-bubble.html-content {
    line-height: 1.6;
  }

  /* Target ALL p tags inside message bubbles */
  .chatbot-message-bubble p {
    margin: 0 0 12px 0;
  }

  .chatbot-message-bubble p:first-child {
    margin-top: 0;
  }

  .chatbot-message-bubble p:last-child {
    margin-bottom: 0;
  }

  .chatbot-message-bubble.html-content ul,
  .chatbot-message-bubble.html-content ol {
    margin: 8px 0;
    padding-left: 20px;
  }

  .chatbot-message-bubble.html-content li {
    margin: 4px 0;
  }

  .chatbot-message-bubble.html-content strong {
    font-weight: 600;
    color: var(--text-primary);
  }

  .chatbot-message-bubble.html-content em {
    font-style: italic;
  }

  .chatbot-message-bubble.html-content code {
    background: var(--bg-tertiary);
    padding: 2px 6px;
    border-radius: 4px;
    font-family: 'Monaco', 'Menlo', monospace;
    font-size: 13px;
  }

  .chatbot-message-bubble.html-content pre {
    background: var(--bg-tertiary);
    padding: 12px;
    border-radius: 6px;
    overflow-x: auto;
    margin: 8px 0;
  }

  .chatbot-message-bubble.html-content pre code {
    background: none;
    padding: 0;
  }

  .chatbot-message-bubble.html-content h1,
  .chatbot-message-bubble.html-content h2,
  .chatbot-message-bubble.html-content h3 {
    margin: 12px 0 8px 0;
    font-weight: 600;
    line-height: 1.3;
  }

  .chatbot-message-bubble.html-content h1 {
    font-size: 18px;
  }

  .chatbot-message-bubble.html-content h2 {
    font-size: 16px;
  }

  .chatbot-message-bubble.html-content h3 {
    font-size: 14px;
  }

  .chatbot-message-bubble.html-content a {
    color: var(--primary-color);
    text-decoration: underline;
  }

  .chatbot-message-bubble.html-content a:hover {
    opacity: 0.8;
  }

  .chatbot-message-bubble.html-content br {
    display: block;
    content: "";
    margin: 4px 0;
  }

  /* Loading indicator / typing animation */
  .chatbot-typing-indicator {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 4px 0;
  }

  .chatbot-typing-indicator span {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--text-secondary);
    opacity: 0.6;
    animation: typing-bounce 1.4s infinite ease-in-out;
  }

  .chatbot-typing-indicator span:nth-child(1) {
    animation-delay: 0s;
  }

  .chatbot-typing-indicator span:nth-child(2) {
    animation-delay: 0.2s;
  }

  .chatbot-typing-indicator span:nth-child(3) {
    animation-delay: 0.4s;
  }

  @keyframes typing-bounce {
    0%, 60%, 100% {
      transform: translateY(0);
      opacity: 0.6;
    }
    30% {
      transform: translateY(-8px);
      opacity: 1;
    }
  }

  /* Loading indicator specific styling */
  .chatbot-message.loading-indicator {
    opacity: 0.8;
  }
`;
const inputStyles = `
  .chatbot-input-container {
    padding: var(--input-padding, 16px);
    border-top: 1px solid var(--border-color);
    background: var(--bg-secondary);
  }

  .chatbot-input-wrapper {
    display: flex;
    gap: 8px;
    align-items: center;
  }

  .chatbot-input {
    flex: 1;
    background: var(--input-bg, var(--bg-primary));
    border: 1px solid var(--input-border, var(--border-color));
    border-radius: var(--radius-sm, 8px);
    padding: 12px 16px;
    color: var(--input-text, var(--text-primary));
    font-size: 14px;
    outline: none;
    transition: border-color 0.2s ease;
  }

  .chatbot-input:focus {
    border-color: var(--primary-color);
  }

  .chatbot-input::placeholder {
    color: var(--input-placeholder, var(--text-muted));
  }

  .chatbot-btn-send {
    background: var(--btn-send-bg, var(--primary-color));
    color: var(--btn-send-color, white);
    border-radius: var(--radius-sm, 8px);
    padding: 12px;
    min-width: 44px;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
  }

  .chatbot-btn-send:hover {
    background: color-mix(in srgb, var(--btn-send-bg, var(--primary-color)) 85%, black);
  }

  .chatbot-btn-send:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
`;
const lightTheme = {
  // Color palette
  primaryColor: "#3B82F6",
  secondaryColor: "#6366F1",
  accentColor: "#8B5CF6",
  // Background colors
  bgPrimary: "#FFFFFF",
  bgSecondary: "#F9FAFB",
  bgTertiary: "#F3F4F6",
  // Text colors
  textPrimary: "#1F2937",
  textSecondary: "#4B5563",
  textMuted: "#6B7280",
  // UI colors
  borderColor: "#E5E7EB",
  shadowColor: "rgba(0, 0, 0, 0.1)",
  // Component-specific
  headerBg: "#F9FAFB",
  headerText: "#1F2937",
  botBubbleBg: "#F3F4F6",
  botBubbleText: "#1F2937",
  userBubbleBg: "#3B82F6",
  userBubbleText: "#FFFFFF",
  inputBg: "#FFFFFF",
  inputBorder: "#E5E7EB",
  inputText: "#1F2937",
  inputPlaceholder: "#9CA3AF",
  // Effects
  shadow: "0 4px 12px rgba(0, 0, 0, 0.08)",
  shadowHover: "0 8px 24px rgba(0, 0, 0, 0.12)"
};
const darkTheme = {
  // Color palette
  primaryColor: "#3B82F6",
  secondaryColor: "#6366F1",
  accentColor: "#8B5CF6",
  // Background colors
  bgPrimary: "#1F2937",
  bgSecondary: "#374151",
  bgTertiary: "#4B5563",
  // Text colors
  textPrimary: "#F9FAFB",
  textSecondary: "#D1D5DB",
  textMuted: "#9CA3AF",
  // UI colors
  borderColor: "#4B5563",
  shadowColor: "rgba(0, 0, 0, 0.3)",
  // Component-specific
  headerBg: "#374151",
  headerText: "#F9FAFB",
  botBubbleBg: "#374151",
  botBubbleText: "#F9FAFB",
  userBubbleBg: "#3B82F6",
  userBubbleText: "#FFFFFF",
  inputBg: "#1F2937",
  inputBorder: "#4B5563",
  inputText: "#F9FAFB",
  inputPlaceholder: "#9CA3AF",
  // Effects
  shadow: "0 10px 25px rgba(0, 0, 0, 0.3)",
  shadowHover: "0 15px 35px rgba(0, 0, 0, 0.4)"
};
function getTheme(themeName) {
  if (themeName === "light") {
    return { ...lightTheme };
  }
  if (themeName === "dark") {
    return { ...darkTheme };
  }
  if (themeName === "auto") {
    if (typeof window !== "undefined" && window.matchMedia) {
      const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
      return prefersDark ? { ...darkTheme } : { ...lightTheme };
    }
    return { ...lightTheme };
  }
  return { ...lightTheme };
}
const getAllStyles = (config) => {
  return `
    ${getBaseStyles(config)}
    ${getLayoutStyles(config)}
    ${headerStyles}
    ${messagesStyles}
    ${inputStyles}
  `;
};
function processComponentStyles(componentStyles = {}) {
  const cssVars = {};
  if (componentStyles.header) {
    const { header } = componentStyles;
    if (header.backgroundColor) cssVars["--header-bg"] = header.backgroundColor;
    if (header.textColor) cssVars["--header-text"] = header.textColor;
    if (header.statusColor) cssVars["--header-status"] = header.statusColor;
    if (header.borderColor) cssVars["--header-border"] = header.borderColor;
    if (header.avatarSize) cssVars["--header-avatar-size"] = header.avatarSize;
    if (header.padding) cssVars["--header-padding"] = header.padding;
  }
  if (componentStyles.messages) {
    const { messages } = componentStyles;
    if (messages.botBubbleBackground) cssVars["--bot-bubble-bg"] = messages.botBubbleBackground;
    if (messages.userBubbleBackground) cssVars["--user-bubble-bg"] = messages.userBubbleBackground;
    if (messages.botTextColor) cssVars["--bot-bubble-text"] = messages.botTextColor;
    if (messages.userTextColor) cssVars["--user-bubble-text"] = messages.userTextColor;
    if (messages.timestampColor) cssVars["--message-timestamp"] = messages.timestampColor;
    if (messages.spacing) cssVars["--message-spacing"] = messages.spacing;
    if (messages.maxWidth) cssVars["--message-max-width"] = messages.maxWidth;
    if (messages.borderRadius) cssVars["--message-radius"] = messages.borderRadius;
    if (messages.avatarSize) cssVars["--message-avatar-size"] = messages.avatarSize;
  }
  if (componentStyles.input) {
    const { input } = componentStyles;
    if (input.backgroundColor) cssVars["--input-bg"] = input.backgroundColor;
    if (input.textColor) cssVars["--input-text"] = input.textColor;
    if (input.borderColor) cssVars["--input-border"] = input.borderColor;
    if (input.placeholderColor) cssVars["--input-placeholder"] = input.placeholderColor;
    if (input.buttonBackground) cssVars["--btn-send-bg"] = input.buttonBackground;
    if (input.buttonColor) cssVars["--btn-send-color"] = input.buttonColor;
    if (input.padding) cssVars["--input-padding"] = input.padding;
  }
  if (componentStyles.layout) {
    const { layout } = componentStyles;
    if (layout.borderRadius) cssVars["--radius"] = layout.borderRadius;
    if (layout.shadow) cssVars["--shadow"] = layout.shadow;
    if (layout.spacing) cssVars["--spacing"] = layout.spacing;
    if (layout.fontFamily) cssVars["--font-family"] = layout.fontFamily;
    if (layout.fontSize) cssVars["--font-size"] = layout.fontSize;
  }
  return cssVars;
}
function processThemeOverrides(themeOverrides = {}) {
  const cssVars = {};
  if (themeOverrides.primaryColor) {
    cssVars["--primary-color"] = themeOverrides.primaryColor;
    cssVars["--user-bubble-bg"] = themeOverrides.primaryColor;
    cssVars["--btn-send-bg"] = themeOverrides.primaryColor;
  }
  if (themeOverrides.secondaryColor) {
    cssVars["--secondary-color"] = themeOverrides.secondaryColor;
  }
  if (themeOverrides.accentColor) {
    cssVars["--accent-color"] = themeOverrides.accentColor;
  }
  if (themeOverrides.fontFamily) {
    cssVars["--font-family"] = themeOverrides.fontFamily;
  }
  if (themeOverrides.fontSize) {
    cssVars["--font-size"] = themeOverrides.fontSize;
  }
  if (themeOverrides.borderRadius) {
    cssVars["--radius"] = themeOverrides.borderRadius;
    cssVars["--radius-sm"] = themeOverrides.borderRadius;
  }
  if (themeOverrides.shadow) {
    cssVars["--shadow"] = themeOverrides.shadow;
  }
  return cssVars;
}
function mergeStyles(baseTheme, componentStyles, themeOverrides) {
  const merged = { ...baseTheme };
  const componentVars = processComponentStyles(componentStyles);
  Object.assign(merged, componentVars);
  const overrideVars = processThemeOverrides(themeOverrides);
  Object.assign(merged, overrideVars);
  return merged;
}
function themeToCSSVariables(theme) {
  return {
    "--primary-color": theme.primaryColor,
    "--secondary-color": theme.secondaryColor,
    "--accent-color": theme.accentColor,
    "--bg-primary": theme.bgPrimary,
    "--bg-secondary": theme.bgSecondary,
    "--bg-tertiary": theme.bgTertiary,
    "--text-primary": theme.textPrimary,
    "--text-secondary": theme.textSecondary,
    "--text-muted": theme.textMuted,
    "--border-color": theme.borderColor,
    "--shadow-color": theme.shadowColor,
    "--shadow": theme.shadow,
    "--header-bg": theme.headerBg,
    "--header-text": theme.headerText,
    "--bot-bubble-bg": theme.botBubbleBg,
    "--bot-bubble-text": theme.botBubbleText,
    "--user-bubble-bg": theme.userBubbleBg,
    "--user-bubble-text": theme.userBubbleText,
    "--input-bg": theme.inputBg,
    "--input-border": theme.inputBorder,
    "--input-text": theme.inputText,
    "--input-placeholder": theme.inputPlaceholder
  };
}
class HttpClient {
  constructor(baseConfig = {}) {
    this.baseURL = baseConfig.baseURL || "";
    this.defaultHeaders = {
      "Content-Type": "application/json",
      ...baseConfig.headers
    };
    this.timeout = baseConfig.timeout || 1e4;
    this.interceptors = {
      request: [],
      response: []
    };
  }
  // Add request interceptor
  addRequestInterceptor(interceptor) {
    this.interceptors.request.push(interceptor);
  }
  // Add response interceptor
  addResponseInterceptor(interceptor) {
    this.interceptors.response.push(interceptor);
  }
  // Apply request interceptors
  async applyRequestInterceptors(config) {
    for (const interceptor of this.interceptors.request) {
      config = await interceptor(config);
    }
    return config;
  }
  // Apply response interceptors
  async applyResponseInterceptors(response) {
    for (const interceptor of this.interceptors.response) {
      response = await interceptor(response);
    }
    return response;
  }
  // Core HTTP request method
  async request(config) {
    try {
      config = await this.applyRequestInterceptors(config);
      const url = config.url.startsWith("http") ? config.url : `${this.baseURL}${config.url}`;
      const headers = {
        ...this.defaultHeaders,
        ...config.headers
      };
      const requestOptions = {
        method: config.method || "GET",
        headers,
        signal: AbortSignal.timeout(this.timeout)
      };
      if (["POST", "PUT", "PATCH"].includes(requestOptions.method.toUpperCase())) {
        if (config.data) {
          if (headers["Content-Type"] === "application/json") {
            requestOptions.body = JSON.stringify(config.data);
          } else {
            requestOptions.body = config.data;
          }
        }
      }
      const response = await fetch(url, requestOptions);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      let data;
      const contentType = response.headers.get("content-type");
      if (contentType && contentType.includes("application/json")) {
        data = await response.json();
      } else {
        data = await response.text();
      }
      const result = {
        data,
        status: response.status,
        statusText: response.statusText,
        headers: Object.fromEntries(response.headers.entries())
      };
      return await this.applyResponseInterceptors(result);
    } catch (error) {
      if (error.name === "AbortError") {
        throw new Error("Request timeout");
      }
      throw error;
    }
  }
  // Convenience methods
  async get(url, config = {}) {
    return this.request({ ...config, method: "GET", url });
  }
  async post(url, data, config = {}) {
    return this.request({ ...config, method: "POST", url, data });
  }
  async put(url, data, config = {}) {
    return this.request({ ...config, method: "PUT", url, data });
  }
  async patch(url, data, config = {}) {
    return this.request({ ...config, method: "PATCH", url, data });
  }
  async delete(url, config = {}) {
    return this.request({ ...config, method: "DELETE", url });
  }
}
class ChatAPI {
  constructor(baseConfig = {}) {
    this.client = new HttpClient(baseConfig);
    this.sessionID = baseConfig.sessionID;
    this.teamName = baseConfig.teamName, this.version = baseConfig.version, this.authToken = baseConfig.authToken;
  }
  // Send message to chat endpoint
  async sendMessage(message, config = {}) {
    const response = await this.client.post(`/chat/query?team_name=${this.teamName}&version=${this.version}`, {
      session_id: this.sessionID,
      query: message,
      team_config_token: this.authToken,
      ...config.data
    }, {
      headers: {
        ...config.headers
      }
    });
    return response.data.payload;
  }
  // Get chat history
  async getChatHistory(config = {}) {
    const response = await this.client.get(`/chat/history?session_id=${this.sessionID}`, {
      headers: {
        ...config.headers
      }
    });
    return response.data.payload.reverse();
  }
  static init(config) {
    const api = new ChatAPI(config);
    return api;
  }
}
if (typeof window !== "undefined") {
  window.ChatAPI = ChatAPI;
}
function L() {
  return { async: false, breaks: false, extensions: null, gfm: true, hooks: null, pedantic: false, renderer: null, silent: false, tokenizer: null, walkTokens: null };
}
var T = L();
function G(u3) {
  T = u3;
}
var I = { exec: () => null };
function d(u3, e = "") {
  let t = typeof u3 == "string" ? u3 : u3.source, n = { replace: (r, i) => {
    let s = typeof i == "string" ? i : i.source;
    return s = s.replace(m.caret, "$1"), t = t.replace(r, s), n;
  }, getRegex: () => new RegExp(t, e) };
  return n;
}
var m = { codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm, outputLinkReplace: /\\([\[\]])/g, indentCodeCompensation: /^(\s+)(?:```)/, beginningSpace: /^\s+/, endingHash: /#$/, startingSpaceChar: /^ /, endingSpaceChar: / $/, nonSpaceChar: /[^ ]/, newLineCharGlobal: /\n/g, tabCharGlobal: /\t/g, multipleSpaceGlobal: /\s+/g, blankLine: /^[ \t]*$/, doubleBlankLine: /\n[ \t]*\n[ \t]*$/, blockquoteStart: /^ {0,3}>/, blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g, blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm, listReplaceTabs: /^\t+/, listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g, listIsTask: /^\[[ xX]\] /, listReplaceTask: /^\[[ xX]\] +/, anyLine: /\n.*\n/, hrefBrackets: /^<(.*)>$/, tableDelimiter: /[:|]/, tableAlignChars: /^\||\| *$/g, tableRowBlankLine: /\n[ \t]*$/, tableAlignRight: /^ *-+: *$/, tableAlignCenter: /^ *:-+: *$/, tableAlignLeft: /^ *:-+ *$/, startATag: /^<a /i, endATag: /^<\/a>/i, startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i, endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i, startAngleBracket: /^</, endAngleBracket: />$/, pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/, unicodeAlphaNumeric: /[\p{L}\p{N}]/u, escapeTest: /[&<>"']/, escapeReplace: /[&<>"']/g, escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g, unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, caret: /(^|[^\[])\^/g, percentDecode: /%25/g, findPipe: /\|/g, splitPipe: / \|/, slashPipe: /\\\|/g, carriageReturn: /\r\n|\r/g, spaceLine: /^ +$/gm, notSpaceStart: /^\S*/, endingNewline: /\n$/, listItemRegex: (u3) => new RegExp(`^( {0,3}${u3})((?:[	 ][^\\n]*)?(?:\\n|$))`), nextBulletRegex: (u3) => new RegExp(`^ {0,${Math.min(3, u3 - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), hrRegex: (u3) => new RegExp(`^ {0,${Math.min(3, u3 - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), fencesBeginRegex: (u3) => new RegExp(`^ {0,${Math.min(3, u3 - 1)}}(?:\`\`\`|~~~)`), headingBeginRegex: (u3) => new RegExp(`^ {0,${Math.min(3, u3 - 1)}}#`), htmlBeginRegex: (u3) => new RegExp(`^ {0,${Math.min(3, u3 - 1)}}<(?:[a-z].*>|!--)`, "i") }, be = /^(?:[ \t]*(?:\n|$))+/, Re = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/, Te = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, E = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, Oe = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, F = /(?:[*+-]|\d{1,9}[.)])/, ie = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/, oe = d(ie).replace(/bull/g, F).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex(), we = d(ie).replace(/bull/g, F).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex(), j = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, ye = /^[^\n]+/, Q = /(?!\s*\])(?:\\[\s\S]|[^\[\]\\])+/, Pe = d(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", Q).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), Se = d(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, F).getRegex(), v = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", U = /<!--(?:-?>|[\s\S]*?(?:-->|$))/, $e = d("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", U).replace("tag", v).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), ae = d(j).replace("hr", E).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", v).getRegex(), _e = d(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", ae).getRegex(), K = { blockquote: _e, code: Re, def: Pe, fences: Te, heading: Oe, hr: E, html: $e, lheading: oe, list: Se, newline: be, paragraph: ae, table: I, text: ye }, re = d("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", E).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", v).getRegex(), Le = { ...K, lheading: we, table: re, paragraph: d(j).replace("hr", E).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", re).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", v).getRegex() }, Me = { ...K, html: d(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", U).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading: /^(#{1,6})(.*)(?:\n+|$)/, fences: I, lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/, paragraph: d(j).replace("hr", E).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", oe).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex() }, ze = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, Ae = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, le = /^( {2,}|\\)\n(?!\s*$)/, Ie = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, D = /[\p{P}\p{S}]/u, W = /[\s\p{P}\p{S}]/u, ue = /[^\s\p{P}\p{S}]/u, Ee = d(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, W).getRegex(), pe = /(?!~)[\p{P}\p{S}]/u, Ce = /(?!~)[\s\p{P}\p{S}]/u, Be = /(?:[^\s\p{P}\p{S}]|~)/u, qe = /\[(?:[^\[\]`]|`[^`]*?`)*?\]\((?:\\[\s\S]|[^\\\(\)]|\((?:\\[\s\S]|[^\\\(\)])*\))*\)|`[^`]*?`|<(?! )[^<>]*?>/g, ce = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/, ve = d(ce, "u").replace(/punct/g, D).getRegex(), De = d(ce, "u").replace(/punct/g, pe).getRegex(), he = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)", He = d(he, "gu").replace(/notPunctSpace/g, ue).replace(/punctSpace/g, W).replace(/punct/g, D).getRegex(), Ze = d(he, "gu").replace(/notPunctSpace/g, Be).replace(/punctSpace/g, Ce).replace(/punct/g, pe).getRegex(), Ge = d("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)", "gu").replace(/notPunctSpace/g, ue).replace(/punctSpace/g, W).replace(/punct/g, D).getRegex(), Ne = d(/\\(punct)/, "gu").replace(/punct/g, D).getRegex(), Fe = d(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), je = d(U).replace("(?:-->|$)", "-->").getRegex(), Qe = d("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", je).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), q = /(?:\[(?:\\[\s\S]|[^\[\]\\])*\]|\\[\s\S]|`+[^`]*?`+(?!`)|[^\[\]\\`])*?/, Ue = d(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label", q).replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), de = d(/^!?\[(label)\]\[(ref)\]/).replace("label", q).replace("ref", Q).getRegex(), ke = d(/^!?\[(ref)\](?:\[\])?/).replace("ref", Q).getRegex(), Ke = d("reflink|nolink(?!\\()", "g").replace("reflink", de).replace("nolink", ke).getRegex(), se = /[hH][tT][tT][pP][sS]?|[fF][tT][pP]/, X = { _backpedal: I, anyPunctuation: Ne, autolink: Fe, blockSkip: qe, br: le, code: Ae, del: I, emStrongLDelim: ve, emStrongRDelimAst: He, emStrongRDelimUnd: Ge, escape: ze, link: Ue, nolink: ke, punctuation: Ee, reflink: de, reflinkSearch: Ke, tag: Qe, text: Ie, url: I }, We = { ...X, link: d(/^!?\[(label)\]\((.*?)\)/).replace("label", q).getRegex(), reflink: d(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", q).getRegex() }, N = { ...X, emStrongRDelimAst: Ze, emStrongLDelim: De, url: d(/^((?:protocol):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/).replace("protocol", se).replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(), _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/, del: /^(~~?)(?=[^\s~])((?:\\[\s\S]|[^\\])*?(?:\\[\s\S]|[^\s~\\]))\1(?=[^~]|$)/, text: d(/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|protocol:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/).replace("protocol", se).getRegex() }, Xe = { ...N, br: d(le).replace("{2,}", "*").getRegex(), text: d(N.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex() }, C = { normal: K, gfm: Le, pedantic: Me }, M = { normal: X, gfm: N, breaks: Xe, pedantic: We };
var Je = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, ge = (u3) => Je[u3];
function w(u3, e) {
  if (e) {
    if (m.escapeTest.test(u3)) return u3.replace(m.escapeReplace, ge);
  } else if (m.escapeTestNoEncode.test(u3)) return u3.replace(m.escapeReplaceNoEncode, ge);
  return u3;
}
function J(u3) {
  try {
    u3 = encodeURI(u3).replace(m.percentDecode, "%");
  } catch {
    return null;
  }
  return u3;
}
function V(u3, e) {
  let t = u3.replace(m.findPipe, (i, s, o) => {
    let a = false, l = s;
    for (; --l >= 0 && o[l] === "\\"; ) a = !a;
    return a ? "|" : " |";
  }), n = t.split(m.splitPipe), r = 0;
  if (n[0].trim() || n.shift(), n.length > 0 && !n.at(-1)?.trim() && n.pop(), e) if (n.length > e) n.splice(e);
  else for (; n.length < e; ) n.push("");
  for (; r < n.length; r++) n[r] = n[r].trim().replace(m.slashPipe, "|");
  return n;
}
function z(u3, e, t) {
  let n = u3.length;
  if (n === 0) return "";
  let r = 0;
  for (; r < n; ) {
    let i = u3.charAt(n - r - 1);
    if (i === e && true) r++;
    else break;
  }
  return u3.slice(0, n - r);
}
function fe(u3, e) {
  if (u3.indexOf(e[1]) === -1) return -1;
  let t = 0;
  for (let n = 0; n < u3.length; n++) if (u3[n] === "\\") n++;
  else if (u3[n] === e[0]) t++;
  else if (u3[n] === e[1] && (t--, t < 0)) return n;
  return t > 0 ? -2 : -1;
}
function me(u3, e, t, n, r) {
  let i = e.href, s = e.title || null, o = u3[1].replace(r.other.outputLinkReplace, "$1");
  n.state.inLink = true;
  let a = { type: u3[0].charAt(0) === "!" ? "image" : "link", raw: t, href: i, title: s, text: o, tokens: n.inlineTokens(o) };
  return n.state.inLink = false, a;
}
function Ve(u3, e, t) {
  let n = u3.match(t.other.indentCodeCompensation);
  if (n === null) return e;
  let r = n[1];
  return e.split(`
`).map((i) => {
    let s = i.match(t.other.beginningSpace);
    if (s === null) return i;
    let [o] = s;
    return o.length >= r.length ? i.slice(r.length) : i;
  }).join(`
`);
}
var y = class {
  options;
  rules;
  lexer;
  constructor(e) {
    this.options = e || T;
  }
  space(e) {
    let t = this.rules.block.newline.exec(e);
    if (t && t[0].length > 0) return { type: "space", raw: t[0] };
  }
  code(e) {
    let t = this.rules.block.code.exec(e);
    if (t) {
      let n = t[0].replace(this.rules.other.codeRemoveIndent, "");
      return { type: "code", raw: t[0], codeBlockStyle: "indented", text: this.options.pedantic ? n : z(n, `
`) };
    }
  }
  fences(e) {
    let t = this.rules.block.fences.exec(e);
    if (t) {
      let n = t[0], r = Ve(n, t[3] || "", this.rules);
      return { type: "code", raw: n, lang: t[2] ? t[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : t[2], text: r };
    }
  }
  heading(e) {
    let t = this.rules.block.heading.exec(e);
    if (t) {
      let n = t[2].trim();
      if (this.rules.other.endingHash.test(n)) {
        let r = z(n, "#");
        (this.options.pedantic || !r || this.rules.other.endingSpaceChar.test(r)) && (n = r.trim());
      }
      return { type: "heading", raw: t[0], depth: t[1].length, text: n, tokens: this.lexer.inline(n) };
    }
  }
  hr(e) {
    let t = this.rules.block.hr.exec(e);
    if (t) return { type: "hr", raw: z(t[0], `
`) };
  }
  blockquote(e) {
    let t = this.rules.block.blockquote.exec(e);
    if (t) {
      let n = z(t[0], `
`).split(`
`), r = "", i = "", s = [];
      for (; n.length > 0; ) {
        let o = false, a = [], l;
        for (l = 0; l < n.length; l++) if (this.rules.other.blockquoteStart.test(n[l])) a.push(n[l]), o = true;
        else if (!o) a.push(n[l]);
        else break;
        n = n.slice(l);
        let c = a.join(`
`), p = c.replace(this.rules.other.blockquoteSetextReplace, `
    $1`).replace(this.rules.other.blockquoteSetextReplace2, "");
        r = r ? `${r}
${c}` : c, i = i ? `${i}
${p}` : p;
        let g = this.lexer.state.top;
        if (this.lexer.state.top = true, this.lexer.blockTokens(p, s, true), this.lexer.state.top = g, n.length === 0) break;
        let h = s.at(-1);
        if (h?.type === "code") break;
        if (h?.type === "blockquote") {
          let R = h, f = R.raw + `
` + n.join(`
`), O = this.blockquote(f);
          s[s.length - 1] = O, r = r.substring(0, r.length - R.raw.length) + O.raw, i = i.substring(0, i.length - R.text.length) + O.text;
          break;
        } else if (h?.type === "list") {
          let R = h, f = R.raw + `
` + n.join(`
`), O = this.list(f);
          s[s.length - 1] = O, r = r.substring(0, r.length - h.raw.length) + O.raw, i = i.substring(0, i.length - R.raw.length) + O.raw, n = f.substring(s.at(-1).raw.length).split(`
`);
          continue;
        }
      }
      return { type: "blockquote", raw: r, tokens: s, text: i };
    }
  }
  list(e) {
    let t = this.rules.block.list.exec(e);
    if (t) {
      let n = t[1].trim(), r = n.length > 1, i = { type: "list", raw: "", ordered: r, start: r ? +n.slice(0, -1) : "", loose: false, items: [] };
      n = r ? `\\d{1,9}\\${n.slice(-1)}` : `\\${n}`, this.options.pedantic && (n = r ? n : "[*+-]");
      let s = this.rules.other.listItemRegex(n), o = false;
      for (; e; ) {
        let l = false, c = "", p = "";
        if (!(t = s.exec(e)) || this.rules.block.hr.test(e)) break;
        c = t[0], e = e.substring(c.length);
        let g = t[2].split(`
`, 1)[0].replace(this.rules.other.listReplaceTabs, (H) => " ".repeat(3 * H.length)), h = e.split(`
`, 1)[0], R = !g.trim(), f = 0;
        if (this.options.pedantic ? (f = 2, p = g.trimStart()) : R ? f = t[1].length + 1 : (f = t[2].search(this.rules.other.nonSpaceChar), f = f > 4 ? 1 : f, p = g.slice(f), f += t[1].length), R && this.rules.other.blankLine.test(h) && (c += h + `
`, e = e.substring(h.length + 1), l = true), !l) {
          let H = this.rules.other.nextBulletRegex(f), ee = this.rules.other.hrRegex(f), te = this.rules.other.fencesBeginRegex(f), ne = this.rules.other.headingBeginRegex(f), xe = this.rules.other.htmlBeginRegex(f);
          for (; e; ) {
            let Z = e.split(`
`, 1)[0], A;
            if (h = Z, this.options.pedantic ? (h = h.replace(this.rules.other.listReplaceNesting, "  "), A = h) : A = h.replace(this.rules.other.tabCharGlobal, "    "), te.test(h) || ne.test(h) || xe.test(h) || H.test(h) || ee.test(h)) break;
            if (A.search(this.rules.other.nonSpaceChar) >= f || !h.trim()) p += `
` + A.slice(f);
            else {
              if (R || g.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4 || te.test(g) || ne.test(g) || ee.test(g)) break;
              p += `
` + h;
            }
            !R && !h.trim() && (R = true), c += Z + `
`, e = e.substring(Z.length + 1), g = A.slice(f);
          }
        }
        i.loose || (o ? i.loose = true : this.rules.other.doubleBlankLine.test(c) && (o = true));
        let O = null, Y;
        this.options.gfm && (O = this.rules.other.listIsTask.exec(p), O && (Y = O[0] !== "[ ] ", p = p.replace(this.rules.other.listReplaceTask, ""))), i.items.push({ type: "list_item", raw: c, task: !!O, checked: Y, loose: false, text: p, tokens: [] }), i.raw += c;
      }
      let a = i.items.at(-1);
      if (a) a.raw = a.raw.trimEnd(), a.text = a.text.trimEnd();
      else return;
      i.raw = i.raw.trimEnd();
      for (let l = 0; l < i.items.length; l++) if (this.lexer.state.top = false, i.items[l].tokens = this.lexer.blockTokens(i.items[l].text, []), !i.loose) {
        let c = i.items[l].tokens.filter((g) => g.type === "space"), p = c.length > 0 && c.some((g) => this.rules.other.anyLine.test(g.raw));
        i.loose = p;
      }
      if (i.loose) for (let l = 0; l < i.items.length; l++) i.items[l].loose = true;
      return i;
    }
  }
  html(e) {
    let t = this.rules.block.html.exec(e);
    if (t) return { type: "html", block: true, raw: t[0], pre: t[1] === "pre" || t[1] === "script" || t[1] === "style", text: t[0] };
  }
  def(e) {
    let t = this.rules.block.def.exec(e);
    if (t) {
      let n = t[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " "), r = t[2] ? t[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", i = t[3] ? t[3].substring(1, t[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : t[3];
      return { type: "def", tag: n, raw: t[0], href: r, title: i };
    }
  }
  table(e) {
    let t = this.rules.block.table.exec(e);
    if (!t || !this.rules.other.tableDelimiter.test(t[2])) return;
    let n = V(t[1]), r = t[2].replace(this.rules.other.tableAlignChars, "").split("|"), i = t[3]?.trim() ? t[3].replace(this.rules.other.tableRowBlankLine, "").split(`
`) : [], s = { type: "table", raw: t[0], header: [], align: [], rows: [] };
    if (n.length === r.length) {
      for (let o of r) this.rules.other.tableAlignRight.test(o) ? s.align.push("right") : this.rules.other.tableAlignCenter.test(o) ? s.align.push("center") : this.rules.other.tableAlignLeft.test(o) ? s.align.push("left") : s.align.push(null);
      for (let o = 0; o < n.length; o++) s.header.push({ text: n[o], tokens: this.lexer.inline(n[o]), header: true, align: s.align[o] });
      for (let o of i) s.rows.push(V(o, s.header.length).map((a, l) => ({ text: a, tokens: this.lexer.inline(a), header: false, align: s.align[l] })));
      return s;
    }
  }
  lheading(e) {
    let t = this.rules.block.lheading.exec(e);
    if (t) return { type: "heading", raw: t[0], depth: t[2].charAt(0) === "=" ? 1 : 2, text: t[1], tokens: this.lexer.inline(t[1]) };
  }
  paragraph(e) {
    let t = this.rules.block.paragraph.exec(e);
    if (t) {
      let n = t[1].charAt(t[1].length - 1) === `
` ? t[1].slice(0, -1) : t[1];
      return { type: "paragraph", raw: t[0], text: n, tokens: this.lexer.inline(n) };
    }
  }
  text(e) {
    let t = this.rules.block.text.exec(e);
    if (t) return { type: "text", raw: t[0], text: t[0], tokens: this.lexer.inline(t[0]) };
  }
  escape(e) {
    let t = this.rules.inline.escape.exec(e);
    if (t) return { type: "escape", raw: t[0], text: t[1] };
  }
  tag(e) {
    let t = this.rules.inline.tag.exec(e);
    if (t) return !this.lexer.state.inLink && this.rules.other.startATag.test(t[0]) ? this.lexer.state.inLink = true : this.lexer.state.inLink && this.rules.other.endATag.test(t[0]) && (this.lexer.state.inLink = false), !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(t[0]) ? this.lexer.state.inRawBlock = true : this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(t[0]) && (this.lexer.state.inRawBlock = false), { type: "html", raw: t[0], inLink: this.lexer.state.inLink, inRawBlock: this.lexer.state.inRawBlock, block: false, text: t[0] };
  }
  link(e) {
    let t = this.rules.inline.link.exec(e);
    if (t) {
      let n = t[2].trim();
      if (!this.options.pedantic && this.rules.other.startAngleBracket.test(n)) {
        if (!this.rules.other.endAngleBracket.test(n)) return;
        let s = z(n.slice(0, -1), "\\");
        if ((n.length - s.length) % 2 === 0) return;
      } else {
        let s = fe(t[2], "()");
        if (s === -2) return;
        if (s > -1) {
          let a = (t[0].indexOf("!") === 0 ? 5 : 4) + t[1].length + s;
          t[2] = t[2].substring(0, s), t[0] = t[0].substring(0, a).trim(), t[3] = "";
        }
      }
      let r = t[2], i = "";
      if (this.options.pedantic) {
        let s = this.rules.other.pedanticHrefTitle.exec(r);
        s && (r = s[1], i = s[3]);
      } else i = t[3] ? t[3].slice(1, -1) : "";
      return r = r.trim(), this.rules.other.startAngleBracket.test(r) && (this.options.pedantic && !this.rules.other.endAngleBracket.test(n) ? r = r.slice(1) : r = r.slice(1, -1)), me(t, { href: r && r.replace(this.rules.inline.anyPunctuation, "$1"), title: i && i.replace(this.rules.inline.anyPunctuation, "$1") }, t[0], this.lexer, this.rules);
    }
  }
  reflink(e, t) {
    let n;
    if ((n = this.rules.inline.reflink.exec(e)) || (n = this.rules.inline.nolink.exec(e))) {
      let r = (n[2] || n[1]).replace(this.rules.other.multipleSpaceGlobal, " "), i = t[r.toLowerCase()];
      if (!i) {
        let s = n[0].charAt(0);
        return { type: "text", raw: s, text: s };
      }
      return me(n, i, n[0], this.lexer, this.rules);
    }
  }
  emStrong(e, t, n = "") {
    let r = this.rules.inline.emStrongLDelim.exec(e);
    if (!r || r[3] && n.match(this.rules.other.unicodeAlphaNumeric)) return;
    if (!(r[1] || r[2] || "") || !n || this.rules.inline.punctuation.exec(n)) {
      let s = [...r[0]].length - 1, o, a, l = s, c = 0, p = r[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      for (p.lastIndex = 0, t = t.slice(-1 * e.length + s); (r = p.exec(t)) != null; ) {
        if (o = r[1] || r[2] || r[3] || r[4] || r[5] || r[6], !o) continue;
        if (a = [...o].length, r[3] || r[4]) {
          l += a;
          continue;
        } else if ((r[5] || r[6]) && s % 3 && !((s + a) % 3)) {
          c += a;
          continue;
        }
        if (l -= a, l > 0) continue;
        a = Math.min(a, a + l + c);
        let g = [...r[0]][0].length, h = e.slice(0, s + r.index + g + a);
        if (Math.min(s, a) % 2) {
          let f = h.slice(1, -1);
          return { type: "em", raw: h, text: f, tokens: this.lexer.inlineTokens(f) };
        }
        let R = h.slice(2, -2);
        return { type: "strong", raw: h, text: R, tokens: this.lexer.inlineTokens(R) };
      }
    }
  }
  codespan(e) {
    let t = this.rules.inline.code.exec(e);
    if (t) {
      let n = t[2].replace(this.rules.other.newLineCharGlobal, " "), r = this.rules.other.nonSpaceChar.test(n), i = this.rules.other.startingSpaceChar.test(n) && this.rules.other.endingSpaceChar.test(n);
      return r && i && (n = n.substring(1, n.length - 1)), { type: "codespan", raw: t[0], text: n };
    }
  }
  br(e) {
    let t = this.rules.inline.br.exec(e);
    if (t) return { type: "br", raw: t[0] };
  }
  del(e) {
    let t = this.rules.inline.del.exec(e);
    if (t) return { type: "del", raw: t[0], text: t[2], tokens: this.lexer.inlineTokens(t[2]) };
  }
  autolink(e) {
    let t = this.rules.inline.autolink.exec(e);
    if (t) {
      let n, r;
      return t[2] === "@" ? (n = t[1], r = "mailto:" + n) : (n = t[1], r = n), { type: "link", raw: t[0], text: n, href: r, tokens: [{ type: "text", raw: n, text: n }] };
    }
  }
  url(e) {
    let t;
    if (t = this.rules.inline.url.exec(e)) {
      let n, r;
      if (t[2] === "@") n = t[0], r = "mailto:" + n;
      else {
        let i;
        do
          i = t[0], t[0] = this.rules.inline._backpedal.exec(t[0])?.[0] ?? "";
        while (i !== t[0]);
        n = t[0], t[1] === "www." ? r = "http://" + t[0] : r = t[0];
      }
      return { type: "link", raw: t[0], text: n, href: r, tokens: [{ type: "text", raw: n, text: n }] };
    }
  }
  inlineText(e) {
    let t = this.rules.inline.text.exec(e);
    if (t) {
      let n = this.lexer.state.inRawBlock;
      return { type: "text", raw: t[0], text: t[0], escaped: n };
    }
  }
};
var x = class u {
  tokens;
  options;
  state;
  tokenizer;
  inlineQueue;
  constructor(e) {
    this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = e || T, this.options.tokenizer = this.options.tokenizer || new y(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = { inLink: false, inRawBlock: false, top: true };
    let t = { other: m, block: C.normal, inline: M.normal };
    this.options.pedantic ? (t.block = C.pedantic, t.inline = M.pedantic) : this.options.gfm && (t.block = C.gfm, this.options.breaks ? t.inline = M.breaks : t.inline = M.gfm), this.tokenizer.rules = t;
  }
  static get rules() {
    return { block: C, inline: M };
  }
  static lex(e, t) {
    return new u(t).lex(e);
  }
  static lexInline(e, t) {
    return new u(t).inlineTokens(e);
  }
  lex(e) {
    e = e.replace(m.carriageReturn, `
`), this.blockTokens(e, this.tokens);
    for (let t = 0; t < this.inlineQueue.length; t++) {
      let n = this.inlineQueue[t];
      this.inlineTokens(n.src, n.tokens);
    }
    return this.inlineQueue = [], this.tokens;
  }
  blockTokens(e, t = [], n = false) {
    for (this.options.pedantic && (e = e.replace(m.tabCharGlobal, "    ").replace(m.spaceLine, "")); e; ) {
      let r;
      if (this.options.extensions?.block?.some((s) => (r = s.call({ lexer: this }, e, t)) ? (e = e.substring(r.raw.length), t.push(r), true) : false)) continue;
      if (r = this.tokenizer.space(e)) {
        e = e.substring(r.raw.length);
        let s = t.at(-1);
        r.raw.length === 1 && s !== void 0 ? s.raw += `
` : t.push(r);
        continue;
      }
      if (r = this.tokenizer.code(e)) {
        e = e.substring(r.raw.length);
        let s = t.at(-1);
        s?.type === "paragraph" || s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + r.raw, s.text += `
` + r.text, this.inlineQueue.at(-1).src = s.text) : t.push(r);
        continue;
      }
      if (r = this.tokenizer.fences(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.heading(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.hr(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.blockquote(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.list(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.html(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.def(e)) {
        e = e.substring(r.raw.length);
        let s = t.at(-1);
        s?.type === "paragraph" || s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + r.raw, s.text += `
` + r.raw, this.inlineQueue.at(-1).src = s.text) : this.tokens.links[r.tag] || (this.tokens.links[r.tag] = { href: r.href, title: r.title }, t.push(r));
        continue;
      }
      if (r = this.tokenizer.table(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.lheading(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      let i = e;
      if (this.options.extensions?.startBlock) {
        let s = 1 / 0, o = e.slice(1), a;
        this.options.extensions.startBlock.forEach((l) => {
          a = l.call({ lexer: this }, o), typeof a == "number" && a >= 0 && (s = Math.min(s, a));
        }), s < 1 / 0 && s >= 0 && (i = e.substring(0, s + 1));
      }
      if (this.state.top && (r = this.tokenizer.paragraph(i))) {
        let s = t.at(-1);
        n && s?.type === "paragraph" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + r.raw, s.text += `
` + r.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s.text) : t.push(r), n = i.length !== e.length, e = e.substring(r.raw.length);
        continue;
      }
      if (r = this.tokenizer.text(e)) {
        e = e.substring(r.raw.length);
        let s = t.at(-1);
        s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + r.raw, s.text += `
` + r.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s.text) : t.push(r);
        continue;
      }
      if (e) {
        let s = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(s);
          break;
        } else throw new Error(s);
      }
    }
    return this.state.top = true, t;
  }
  inline(e, t = []) {
    return this.inlineQueue.push({ src: e, tokens: t }), t;
  }
  inlineTokens(e, t = []) {
    let n = e, r = null;
    if (this.tokens.links) {
      let o = Object.keys(this.tokens.links);
      if (o.length > 0) for (; (r = this.tokenizer.rules.inline.reflinkSearch.exec(n)) != null; ) o.includes(r[0].slice(r[0].lastIndexOf("[") + 1, -1)) && (n = n.slice(0, r.index) + "[" + "a".repeat(r[0].length - 2) + "]" + n.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
    }
    for (; (r = this.tokenizer.rules.inline.anyPunctuation.exec(n)) != null; ) n = n.slice(0, r.index) + "++" + n.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    for (; (r = this.tokenizer.rules.inline.blockSkip.exec(n)) != null; ) n = n.slice(0, r.index) + "[" + "a".repeat(r[0].length - 2) + "]" + n.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    n = this.options.hooks?.emStrongMask?.call({ lexer: this }, n) ?? n;
    let i = false, s = "";
    for (; e; ) {
      i || (s = ""), i = false;
      let o;
      if (this.options.extensions?.inline?.some((l) => (o = l.call({ lexer: this }, e, t)) ? (e = e.substring(o.raw.length), t.push(o), true) : false)) continue;
      if (o = this.tokenizer.escape(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.tag(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.link(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.reflink(e, this.tokens.links)) {
        e = e.substring(o.raw.length);
        let l = t.at(-1);
        o.type === "text" && l?.type === "text" ? (l.raw += o.raw, l.text += o.text) : t.push(o);
        continue;
      }
      if (o = this.tokenizer.emStrong(e, n, s)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.codespan(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.br(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.del(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.autolink(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (!this.state.inLink && (o = this.tokenizer.url(e))) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      let a = e;
      if (this.options.extensions?.startInline) {
        let l = 1 / 0, c = e.slice(1), p;
        this.options.extensions.startInline.forEach((g) => {
          p = g.call({ lexer: this }, c), typeof p == "number" && p >= 0 && (l = Math.min(l, p));
        }), l < 1 / 0 && l >= 0 && (a = e.substring(0, l + 1));
      }
      if (o = this.tokenizer.inlineText(a)) {
        e = e.substring(o.raw.length), o.raw.slice(-1) !== "_" && (s = o.raw.slice(-1)), i = true;
        let l = t.at(-1);
        l?.type === "text" ? (l.raw += o.raw, l.text += o.text) : t.push(o);
        continue;
      }
      if (e) {
        let l = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(l);
          break;
        } else throw new Error(l);
      }
    }
    return t;
  }
};
var P = class {
  options;
  parser;
  constructor(e) {
    this.options = e || T;
  }
  space(e) {
    return "";
  }
  code({ text: e, lang: t, escaped: n }) {
    let r = (t || "").match(m.notSpaceStart)?.[0], i = e.replace(m.endingNewline, "") + `
`;
    return r ? '<pre><code class="language-' + w(r) + '">' + (n ? i : w(i, true)) + `</code></pre>
` : "<pre><code>" + (n ? i : w(i, true)) + `</code></pre>
`;
  }
  blockquote({ tokens: e }) {
    return `<blockquote>
${this.parser.parse(e)}</blockquote>
`;
  }
  html({ text: e }) {
    return e;
  }
  def(e) {
    return "";
  }
  heading({ tokens: e, depth: t }) {
    return `<h${t}>${this.parser.parseInline(e)}</h${t}>
`;
  }
  hr(e) {
    return `<hr>
`;
  }
  list(e) {
    let t = e.ordered, n = e.start, r = "";
    for (let o = 0; o < e.items.length; o++) {
      let a = e.items[o];
      r += this.listitem(a);
    }
    let i = t ? "ol" : "ul", s = t && n !== 1 ? ' start="' + n + '"' : "";
    return "<" + i + s + `>
` + r + "</" + i + `>
`;
  }
  listitem(e) {
    let t = "";
    if (e.task) {
      let n = this.checkbox({ checked: !!e.checked });
      e.loose ? e.tokens[0]?.type === "paragraph" ? (e.tokens[0].text = n + " " + e.tokens[0].text, e.tokens[0].tokens && e.tokens[0].tokens.length > 0 && e.tokens[0].tokens[0].type === "text" && (e.tokens[0].tokens[0].text = n + " " + w(e.tokens[0].tokens[0].text), e.tokens[0].tokens[0].escaped = true)) : e.tokens.unshift({ type: "text", raw: n + " ", text: n + " ", escaped: true }) : t += n + " ";
    }
    return t += this.parser.parse(e.tokens, !!e.loose), `<li>${t}</li>
`;
  }
  checkbox({ checked: e }) {
    return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph({ tokens: e }) {
    return `<p>${this.parser.parseInline(e)}</p>
`;
  }
  table(e) {
    let t = "", n = "";
    for (let i = 0; i < e.header.length; i++) n += this.tablecell(e.header[i]);
    t += this.tablerow({ text: n });
    let r = "";
    for (let i = 0; i < e.rows.length; i++) {
      let s = e.rows[i];
      n = "";
      for (let o = 0; o < s.length; o++) n += this.tablecell(s[o]);
      r += this.tablerow({ text: n });
    }
    return r && (r = `<tbody>${r}</tbody>`), `<table>
<thead>
` + t + `</thead>
` + r + `</table>
`;
  }
  tablerow({ text: e }) {
    return `<tr>
${e}</tr>
`;
  }
  tablecell(e) {
    let t = this.parser.parseInline(e.tokens), n = e.header ? "th" : "td";
    return (e.align ? `<${n} align="${e.align}">` : `<${n}>`) + t + `</${n}>
`;
  }
  strong({ tokens: e }) {
    return `<strong>${this.parser.parseInline(e)}</strong>`;
  }
  em({ tokens: e }) {
    return `<em>${this.parser.parseInline(e)}</em>`;
  }
  codespan({ text: e }) {
    return `<code>${w(e, true)}</code>`;
  }
  br(e) {
    return "<br>";
  }
  del({ tokens: e }) {
    return `<del>${this.parser.parseInline(e)}</del>`;
  }
  link({ href: e, title: t, tokens: n }) {
    let r = this.parser.parseInline(n), i = J(e);
    if (i === null) return r;
    e = i;
    let s = '<a href="' + e + '"';
    return t && (s += ' title="' + w(t) + '"'), s += ">" + r + "</a>", s;
  }
  image({ href: e, title: t, text: n, tokens: r }) {
    r && (n = this.parser.parseInline(r, this.parser.textRenderer));
    let i = J(e);
    if (i === null) return w(n);
    e = i;
    let s = `<img src="${e}" alt="${n}"`;
    return t && (s += ` title="${w(t)}"`), s += ">", s;
  }
  text(e) {
    return "tokens" in e && e.tokens ? this.parser.parseInline(e.tokens) : "escaped" in e && e.escaped ? e.text : w(e.text);
  }
};
var $ = class {
  strong({ text: e }) {
    return e;
  }
  em({ text: e }) {
    return e;
  }
  codespan({ text: e }) {
    return e;
  }
  del({ text: e }) {
    return e;
  }
  html({ text: e }) {
    return e;
  }
  text({ text: e }) {
    return e;
  }
  link({ text: e }) {
    return "" + e;
  }
  image({ text: e }) {
    return "" + e;
  }
  br() {
    return "";
  }
};
var b = class u2 {
  options;
  renderer;
  textRenderer;
  constructor(e) {
    this.options = e || T, this.options.renderer = this.options.renderer || new P(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new $();
  }
  static parse(e, t) {
    return new u2(t).parse(e);
  }
  static parseInline(e, t) {
    return new u2(t).parseInline(e);
  }
  parse(e, t = true) {
    let n = "";
    for (let r = 0; r < e.length; r++) {
      let i = e[r];
      if (this.options.extensions?.renderers?.[i.type]) {
        let o = i, a = this.options.extensions.renderers[o.type].call({ parser: this }, o);
        if (a !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "def", "paragraph", "text"].includes(o.type)) {
          n += a || "";
          continue;
        }
      }
      let s = i;
      switch (s.type) {
        case "space": {
          n += this.renderer.space(s);
          continue;
        }
        case "hr": {
          n += this.renderer.hr(s);
          continue;
        }
        case "heading": {
          n += this.renderer.heading(s);
          continue;
        }
        case "code": {
          n += this.renderer.code(s);
          continue;
        }
        case "table": {
          n += this.renderer.table(s);
          continue;
        }
        case "blockquote": {
          n += this.renderer.blockquote(s);
          continue;
        }
        case "list": {
          n += this.renderer.list(s);
          continue;
        }
        case "html": {
          n += this.renderer.html(s);
          continue;
        }
        case "def": {
          n += this.renderer.def(s);
          continue;
        }
        case "paragraph": {
          n += this.renderer.paragraph(s);
          continue;
        }
        case "text": {
          let o = s, a = this.renderer.text(o);
          for (; r + 1 < e.length && e[r + 1].type === "text"; ) o = e[++r], a += `
` + this.renderer.text(o);
          t ? n += this.renderer.paragraph({ type: "paragraph", raw: a, text: a, tokens: [{ type: "text", raw: a, text: a, escaped: true }] }) : n += a;
          continue;
        }
        default: {
          let o = 'Token with "' + s.type + '" type was not found.';
          if (this.options.silent) return console.error(o), "";
          throw new Error(o);
        }
      }
    }
    return n;
  }
  parseInline(e, t = this.renderer) {
    let n = "";
    for (let r = 0; r < e.length; r++) {
      let i = e[r];
      if (this.options.extensions?.renderers?.[i.type]) {
        let o = this.options.extensions.renderers[i.type].call({ parser: this }, i);
        if (o !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(i.type)) {
          n += o || "";
          continue;
        }
      }
      let s = i;
      switch (s.type) {
        case "escape": {
          n += t.text(s);
          break;
        }
        case "html": {
          n += t.html(s);
          break;
        }
        case "link": {
          n += t.link(s);
          break;
        }
        case "image": {
          n += t.image(s);
          break;
        }
        case "strong": {
          n += t.strong(s);
          break;
        }
        case "em": {
          n += t.em(s);
          break;
        }
        case "codespan": {
          n += t.codespan(s);
          break;
        }
        case "br": {
          n += t.br(s);
          break;
        }
        case "del": {
          n += t.del(s);
          break;
        }
        case "text": {
          n += t.text(s);
          break;
        }
        default: {
          let o = 'Token with "' + s.type + '" type was not found.';
          if (this.options.silent) return console.error(o), "";
          throw new Error(o);
        }
      }
    }
    return n;
  }
};
var S = class {
  options;
  block;
  constructor(e) {
    this.options = e || T;
  }
  static passThroughHooks = /* @__PURE__ */ new Set(["preprocess", "postprocess", "processAllTokens", "emStrongMask"]);
  static passThroughHooksRespectAsync = /* @__PURE__ */ new Set(["preprocess", "postprocess", "processAllTokens"]);
  preprocess(e) {
    return e;
  }
  postprocess(e) {
    return e;
  }
  processAllTokens(e) {
    return e;
  }
  emStrongMask(e) {
    return e;
  }
  provideLexer() {
    return this.block ? x.lex : x.lexInline;
  }
  provideParser() {
    return this.block ? b.parse : b.parseInline;
  }
};
var B = class {
  defaults = L();
  options = this.setOptions;
  parse = this.parseMarkdown(true);
  parseInline = this.parseMarkdown(false);
  Parser = b;
  Renderer = P;
  TextRenderer = $;
  Lexer = x;
  Tokenizer = y;
  Hooks = S;
  constructor(...e) {
    this.use(...e);
  }
  walkTokens(e, t) {
    let n = [];
    for (let r of e) switch (n = n.concat(t.call(this, r)), r.type) {
      case "table": {
        let i = r;
        for (let s of i.header) n = n.concat(this.walkTokens(s.tokens, t));
        for (let s of i.rows) for (let o of s) n = n.concat(this.walkTokens(o.tokens, t));
        break;
      }
      case "list": {
        let i = r;
        n = n.concat(this.walkTokens(i.items, t));
        break;
      }
      default: {
        let i = r;
        this.defaults.extensions?.childTokens?.[i.type] ? this.defaults.extensions.childTokens[i.type].forEach((s) => {
          let o = i[s].flat(1 / 0);
          n = n.concat(this.walkTokens(o, t));
        }) : i.tokens && (n = n.concat(this.walkTokens(i.tokens, t)));
      }
    }
    return n;
  }
  use(...e) {
    let t = this.defaults.extensions || { renderers: {}, childTokens: {} };
    return e.forEach((n) => {
      let r = { ...n };
      if (r.async = this.defaults.async || r.async || false, n.extensions && (n.extensions.forEach((i) => {
        if (!i.name) throw new Error("extension name required");
        if ("renderer" in i) {
          let s = t.renderers[i.name];
          s ? t.renderers[i.name] = function(...o) {
            let a = i.renderer.apply(this, o);
            return a === false && (a = s.apply(this, o)), a;
          } : t.renderers[i.name] = i.renderer;
        }
        if ("tokenizer" in i) {
          if (!i.level || i.level !== "block" && i.level !== "inline") throw new Error("extension level must be 'block' or 'inline'");
          let s = t[i.level];
          s ? s.unshift(i.tokenizer) : t[i.level] = [i.tokenizer], i.start && (i.level === "block" ? t.startBlock ? t.startBlock.push(i.start) : t.startBlock = [i.start] : i.level === "inline" && (t.startInline ? t.startInline.push(i.start) : t.startInline = [i.start]));
        }
        "childTokens" in i && i.childTokens && (t.childTokens[i.name] = i.childTokens);
      }), r.extensions = t), n.renderer) {
        let i = this.defaults.renderer || new P(this.defaults);
        for (let s in n.renderer) {
          if (!(s in i)) throw new Error(`renderer '${s}' does not exist`);
          if (["options", "parser"].includes(s)) continue;
          let o = s, a = n.renderer[o], l = i[o];
          i[o] = (...c) => {
            let p = a.apply(i, c);
            return p === false && (p = l.apply(i, c)), p || "";
          };
        }
        r.renderer = i;
      }
      if (n.tokenizer) {
        let i = this.defaults.tokenizer || new y(this.defaults);
        for (let s in n.tokenizer) {
          if (!(s in i)) throw new Error(`tokenizer '${s}' does not exist`);
          if (["options", "rules", "lexer"].includes(s)) continue;
          let o = s, a = n.tokenizer[o], l = i[o];
          i[o] = (...c) => {
            let p = a.apply(i, c);
            return p === false && (p = l.apply(i, c)), p;
          };
        }
        r.tokenizer = i;
      }
      if (n.hooks) {
        let i = this.defaults.hooks || new S();
        for (let s in n.hooks) {
          if (!(s in i)) throw new Error(`hook '${s}' does not exist`);
          if (["options", "block"].includes(s)) continue;
          let o = s, a = n.hooks[o], l = i[o];
          S.passThroughHooks.has(s) ? i[o] = (c) => {
            if (this.defaults.async && S.passThroughHooksRespectAsync.has(s)) return (async () => {
              let g = await a.call(i, c);
              return l.call(i, g);
            })();
            let p = a.call(i, c);
            return l.call(i, p);
          } : i[o] = (...c) => {
            if (this.defaults.async) return (async () => {
              let g = await a.apply(i, c);
              return g === false && (g = await l.apply(i, c)), g;
            })();
            let p = a.apply(i, c);
            return p === false && (p = l.apply(i, c)), p;
          };
        }
        r.hooks = i;
      }
      if (n.walkTokens) {
        let i = this.defaults.walkTokens, s = n.walkTokens;
        r.walkTokens = function(o) {
          let a = [];
          return a.push(s.call(this, o)), i && (a = a.concat(i.call(this, o))), a;
        };
      }
      this.defaults = { ...this.defaults, ...r };
    }), this;
  }
  setOptions(e) {
    return this.defaults = { ...this.defaults, ...e }, this;
  }
  lexer(e, t) {
    return x.lex(e, t ?? this.defaults);
  }
  parser(e, t) {
    return b.parse(e, t ?? this.defaults);
  }
  parseMarkdown(e) {
    return (n, r) => {
      let i = { ...r }, s = { ...this.defaults, ...i }, o = this.onError(!!s.silent, !!s.async);
      if (this.defaults.async === true && i.async === false) return o(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
      if (typeof n > "u" || n === null) return o(new Error("marked(): input parameter is undefined or null"));
      if (typeof n != "string") return o(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(n) + ", string expected"));
      if (s.hooks && (s.hooks.options = s, s.hooks.block = e), s.async) return (async () => {
        let a = s.hooks ? await s.hooks.preprocess(n) : n, c = await (s.hooks ? await s.hooks.provideLexer() : e ? x.lex : x.lexInline)(a, s), p = s.hooks ? await s.hooks.processAllTokens(c) : c;
        s.walkTokens && await Promise.all(this.walkTokens(p, s.walkTokens));
        let h = await (s.hooks ? await s.hooks.provideParser() : e ? b.parse : b.parseInline)(p, s);
        return s.hooks ? await s.hooks.postprocess(h) : h;
      })().catch(o);
      try {
        s.hooks && (n = s.hooks.preprocess(n));
        let l = (s.hooks ? s.hooks.provideLexer() : e ? x.lex : x.lexInline)(n, s);
        s.hooks && (l = s.hooks.processAllTokens(l)), s.walkTokens && this.walkTokens(l, s.walkTokens);
        let p = (s.hooks ? s.hooks.provideParser() : e ? b.parse : b.parseInline)(l, s);
        return s.hooks && (p = s.hooks.postprocess(p)), p;
      } catch (a) {
        return o(a);
      }
    };
  }
  onError(e, t) {
    return (n) => {
      if (n.message += `
Please report this to https://github.com/markedjs/marked.`, e) {
        let r = "<p>An error occurred:</p><pre>" + w(n.message + "", true) + "</pre>";
        return t ? Promise.resolve(r) : r;
      }
      if (t) return Promise.reject(n);
      throw n;
    };
  }
};
var _ = new B();
function k(u3, e) {
  return _.parse(u3, e);
}
k.options = k.setOptions = function(u3) {
  return _.setOptions(u3), k.defaults = _.defaults, G(k.defaults), k;
};
k.getDefaults = L;
k.defaults = T;
k.use = function(...u3) {
  return _.use(...u3), k.defaults = _.defaults, G(k.defaults), k;
};
k.walkTokens = function(u3, e) {
  return _.walkTokens(u3, e);
};
k.parseInline = _.parseInline;
k.Parser = b;
k.parser = b.parse;
k.Renderer = P;
k.TextRenderer = $;
k.Lexer = x;
k.lexer = x.lex;
k.Tokenizer = y;
k.Hooks = S;
k.parse = k;
k.options;
k.setOptions;
k.use;
k.walkTokens;
k.parseInline;
b.parse;
x.lex;
function markdownToHtml(markdown) {
  if (!markdown) return "";
  k.setOptions({
    breaks: true,
    gfm: true
  });
  return k(markdown);
}
function formatText(text) {
  if (!text) return "";
  return text.replace(/\n\n/g, "</p><p>").replace(/\n/g, "<br>").replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>").replace(/\*(.*?)\*/g, "<em>$1</em>");
}
function sanitizeHtml(html) {
  const div = document.createElement("div");
  div.textContent = html;
  return div.innerHTML;
}
class ChatbotWidget {
  constructor(config = {}) {
    this.config = this.mergeConfig(config);
    this.shadowRoot = null;
    this.isOpen = false;
    this.messages = [];
    this.chatToggle = new ChatToggle(this.config);
    this.chatWindow = new ChatWindow(this.config);
    this.messageComponent = new Message(this.config);
    this.loadingIndicator = new LoadingIndicator(this.config);
  }
  static async Init(config = {}) {
    const widget = new ChatbotWidget(config);
    await widget.init();
    return widget;
  }
  mergeConfig(userConfig) {
    const defaults = {
      // Layout options
      layout: "inline",
      // 'inline', 'bubble', 'embedded', 'fullscreen', 'modal'
      target: "body",
      width: "100%",
      height: "600px",
      // Positioning (only for bubble layout)
      position: "bottom-right",
      // Display options
      autoOpen: false,
      showToggle: true,
      showGreeting: true,
      // Theme options
      theme: "dark",
      // 'light', 'dark', 'auto'
      primaryColor: "#3B82F6",
      // Backward compatibility
      // Component-level styles
      componentStyles: {},
      // Theme overrides
      themeOverrides: {},
      // Custom CSS string
      customStyles: "",
      // Content
      greeting: "Hi! How can I help you today?",
      placeholder: "Write a message...",
      initialMessages: [],
      // Avatars
      avatar: {
        bot: "src/assets/chat-bot.jpg",
        user: "src/assets/user.jpg"
      },
      // Callbacks
      onMessage: null,
      onOpen: null,
      onClose: null,
      apiConfig: {}
      // overwrite it with config from sdk Init()
    };
    const merged = { ...defaults, ...userConfig };
    merged.processedTheme = this.processTheme(merged);
    return merged;
  }
  processTheme(config) {
    const baseTheme = getTheme(config.theme);
    if (config.primaryColor && config.primaryColor !== "#3B82F6") {
      config.themeOverrides = config.themeOverrides || {};
      if (!config.themeOverrides.primaryColor) {
        config.themeOverrides.primaryColor = config.primaryColor;
      }
    }
    const mergedTheme = mergeStyles(
      baseTheme,
      config.componentStyles,
      config.themeOverrides
    );
    const cssVariables = themeToCSSVariables(mergedTheme);
    if (mergedTheme["--radius"]) cssVariables["--radius"] = mergedTheme["--radius"];
    if (mergedTheme["--radius-sm"]) cssVariables["--radius-sm"] = mergedTheme["--radius-sm"];
    if (mergedTheme["--shadow"]) cssVariables["--shadow"] = mergedTheme["--shadow"];
    if (mergedTheme["--font-family"]) cssVariables["--font-family"] = mergedTheme["--font-family"];
    if (mergedTheme["--font-size"]) cssVariables["--font-size"] = mergedTheme["--font-size"];
    Object.keys(mergedTheme).forEach((key) => {
      if (key.startsWith("--") && !cssVariables[key]) {
        cssVariables[key] = mergedTheme[key];
      }
    });
    return cssVariables;
  }
  async init() {
    this.api = new ChatAPI(this.config.apiConfig);
    await this.createWidget();
    this.attachStyles();
    this.attachEventListeners();
    if (this.config.autoOpen) {
      this.open();
    }
  }
  async createWidget() {
    const container = document.createElement("div");
    container.className = `chatbot-widget chatbot-layout-${this.config.layout}`;
    if (this.config.layout === "modal") {
      container.innerHTML = `
        <div class="chatbot-modal-backdrop"></div>
        ${this.chatWindow.render()}
        <button class="chatbot-modal-close" id="chatbot-modal-close">×</button>
      `;
    } else {
      container.innerHTML = `
        ${this.chatToggle.render()}
        ${this.chatWindow.render()}
      `;
    }
    if (typeof this.config.target === "string") {
      this.target = document.querySelector(this.config.target);
    } else if (this.config.target instanceof Element) {
      this.target = this.config.target;
    } else {
      this.target = document.body;
    }
    if (!this.target) {
      throw new Error(`Target element not found: ${this.config.target}`);
    }
    this.shadowRoot = this.target.attachShadow({ mode: "open" });
    this.shadowRoot.appendChild(container);
    await this.addWelcomeMessage();
  }
  attachStyles() {
    const baseStyle = document.createElement("style");
    baseStyle.textContent = getAllStyles(this.config);
    this.shadowRoot.appendChild(baseStyle);
    if (this.config.customStyles && typeof this.config.customStyles === "string") {
      const customStyle = document.createElement("style");
      customStyle.textContent = this.config.customStyles;
      this.shadowRoot.appendChild(customStyle);
    }
  }
  attachEventListeners() {
    if (this.config.layout === "modal") {
      const backdrop = this.shadowRoot.querySelector(".chatbot-modal-backdrop");
      const modalClose = this.shadowRoot.getElementById("chatbot-modal-close");
      const sendBtn = this.shadowRoot.getElementById("chatbot-send");
      const input = this.shadowRoot.getElementById("chatbot-input");
      if (backdrop) {
        backdrop.addEventListener("click", () => this.close());
      }
      if (modalClose) {
        modalClose.addEventListener("click", () => this.close());
      }
      sendBtn.addEventListener("click", () => this.sendMessage());
      input.addEventListener("keypress", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          this.sendMessage();
        }
      });
    } else {
      const toggle = this.shadowRoot.getElementById("chatbot-toggle");
      const minimize = this.shadowRoot.getElementById("chatbot-minimize");
      const sendBtn = this.shadowRoot.getElementById("chatbot-send");
      const input = this.shadowRoot.getElementById("chatbot-input");
      if (toggle) {
        toggle.addEventListener("click", () => this.toggle());
      }
      if (minimize) {
        minimize.addEventListener("click", () => this.close());
      }
      sendBtn.addEventListener("click", () => this.sendMessage());
      input.addEventListener("keypress", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          this.sendMessage();
        }
      });
    }
  }
  toggle() {
    if (this.isOpen) {
      this.close();
    } else {
      this.open();
    }
  }
  open() {
    if (this.config.layout === "modal") {
      const container = this.shadowRoot.querySelector(".chatbot-widget");
      if (container) {
        container.classList.add("open");
      }
    } else {
      const window2 = this.shadowRoot.getElementById("chatbot-window");
      if (["inline", "embedded", "fullscreen"].includes(this.config.layout)) {
        window2.style.display = "flex";
      } else {
        window2.classList.add("open");
      }
    }
    this.isOpen = true;
    if (this.config.onOpen) {
      this.config.onOpen();
    }
  }
  close() {
    if (this.config.layout === "inline") {
      return;
    }
    if (this.config.layout === "modal") {
      const container = this.shadowRoot.querySelector(".chatbot-widget");
      if (container) {
        container.classList.remove("open");
      }
    } else {
      const window2 = this.shadowRoot.getElementById("chatbot-window");
      if (this.config.layout === "bubble") {
        window2.classList.remove("open");
      } else {
        window2.style.display = "none";
      }
    }
    this.isOpen = false;
    if (this.config.onClose) {
      this.config.onClose();
    }
  }
  async addWelcomeMessage() {
    const initialMessages = await this.api.getChatHistory();
    if (initialMessages && initialMessages.length > 0) {
      initialMessages.forEach((msg) => {
        const htmlContent = markdownToHtml(msg.content);
        this.addMessage({
          text: htmlContent,
          sender: msg.source === "user" ? "user" : "bot",
          timestamp: new Date(msg.created_at)
        });
      });
    } else if (this.config.showGreeting) {
      this.addMessage({
        text: this.config.greeting,
        sender: "bot",
        timestamp: /* @__PURE__ */ new Date()
      });
    }
  }
  // TODO: get timestamp from the backend 
  addMessage({ text, html, isHtml, sender, timestamp = /* @__PURE__ */ new Date() }) {
    const messagesContainer = this.shadowRoot.getElementById("chatbot-messages");
    const tempContainer = document.createElement("div");
    tempContainer.innerHTML = this.messageComponent.render({
      text,
      html,
      isHtml,
      sender,
      timestamp
    });
    messagesContainer.appendChild(tempContainer.firstElementChild);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
    this.messages.push({ text: html || text, sender, timestamp });
  }
  showLoadingIndicator() {
    const messagesContainer = this.shadowRoot.getElementById("chatbot-messages");
    const tempContainer = document.createElement("div");
    tempContainer.innerHTML = this.loadingIndicator.render();
    messagesContainer.appendChild(tempContainer.firstElementChild);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
  }
  hideLoadingIndicator() {
    const loadingElement = this.shadowRoot.getElementById("chatbot-loading");
    if (loadingElement) {
      loadingElement.remove();
    }
  }
  async sendMessage() {
    const input = this.shadowRoot.getElementById("chatbot-input");
    const text = input.value.trim();
    if (!text) return;
    input.value = "";
    this.addMessage({ text, sender: "user", timestamp: /* @__PURE__ */ new Date() });
    if (this.api) {
      try {
        this.showLoadingIndicator();
        const response = await this.api.sendMessage(text);
        this.hideLoadingIndicator();
        if (response && response.content) {
          const mdContent = response.content;
          const htmlContent = markdownToHtml(mdContent);
          this.addMessage({
            html: htmlContent,
            isHtml: true,
            sender: "bot",
            timestamp: /* @__PURE__ */ new Date()
            // get it from DB
          });
        } else if (typeof response === "string") {
          this.addMessage({
            text: response,
            sender: "bot",
            timestamp: /* @__PURE__ */ new Date()
          });
        } else {
          console.error("Unexpected response format:", response);
          this.addMessage({
            text: "I received your message but got an unexpected response format.",
            sender: "bot",
            timestamp: /* @__PURE__ */ new Date()
          });
        }
      } catch (error) {
        this.hideLoadingIndicator();
        console.log("Error", error);
        this.addMessage({
          text: "Sorry, something went wrong. Please try again.",
          sender: "bot",
          timestamp: /* @__PURE__ */ new Date()
        });
      }
    }
  }
  destroy() {
    if (this.shadowRoot && this.target) {
      this.target.shadowRoot = null;
    }
  }
}
if (typeof window !== "undefined") {
  window.ChatbotWidget = ChatbotWidget;
}
export {
  ChatAPI,
  ChatbotWidget,
  ChatbotWidget as default,
  formatText,
  markdownToHtml,
  sanitizeHtml
};
